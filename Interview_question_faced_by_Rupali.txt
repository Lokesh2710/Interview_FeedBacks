
#==> Capgemini
-----------------------------------------------------------------------------------------------------------
Q.1)Explain @Qualifier ???
==>By using the @Qualifier annotation, you can explicitly control which bean should be used for dependency injection when there are multiple candidates of the same type in the Spring application context. @Qualifier annotation is used with @Autowaired annotation and use to identify the object when same types of multiple objects present.


Q.2)Diff Truncate vs Delete ??
==> 
TRUNCATE: It is a Data Definition Language (DDL) statement. This means it's used for structural changes to a table and can't be rolled back (in most databases). 
1.It's used to quickly remove all rows from a table.
2.Faster than DELETE 
3.cannot specify a WHERE condition
4.TRUNCATE usually does not fire triggers, and it may not enforce referential integrity constraints (foreign keys). It's typically a more brute-force operation.

DELETE: It is a Data Manipulation Language (DML) statement. It's used for removing specific rows from a table based on a specified condition.

Q.3) Diff  TRUNCATE vs DROP Command
==> TRUNCATE TABLE table_name;: This command is used to quickly and efficiently remove all rows from a table while keeping the table structure intact. It's used when you want to clear the data from a table but retain the table itself.

DROP TABLE table_name;: This command is used to completely delete the table, including both its structure and all of its data. It's used when you want to remove the entire table and all its contents.


Q.4)How to delete dublicate record??
==>>   
    DELETE FROM your_table
    WHERE id NOT IN (
    SELECT MIN(id)   -- Keep only one copy of the duplicates (choose any)
    FROM your_table
    GROUP BY column1, column2
	);

	or 

	SELECT DISTINCT column_name
	FROM table_name;

	or

	SELECT column_name
    FROM table_name
    GROUP BY column_name;
	
	or 
	
	-- Step 3: Delete Duplicate Records
	DELETE FROM your_table
	WHERE (email, id) NOT IN (
    SELECT email, MIN(id)
    FROM your_table
    GROUP BY email
	);


Q.5 )What server used in your project?? 
==> Tomcat server , MySql Database

Q.6) How to remove merge conflict???
==>Merge conflicts occur in version control systems like Git when two or more branches have made changes to the same part of a file and the system can't automatically determine which change to accept. Resolving merge conflicts involves manually choosing which changes to keep and which to discard. Here's a step-by-step guide on how to remove merge conflicts:
1. **Pull Changes**: Before you start, make sure your local branch is up to date. Use the following commands:
   ```bash
   git fetch origin
   git checkout your_branch
   git merge origin/your_branch
   ```
   This will pull the latest changes from the remote repository.
2. **Identify Conflicts**: When you pull or merge changes, Git will identify conflicts and indicate them in the affected files. Open these files in a text editor, and you'll see conflict markers like this:
   ```plaintext
   <<<<<<< HEAD
   This is your local change.
   =======
   This is the incoming change.
   >>>>>>> branch_name
   ```
   The lines between `<<<<<<< HEAD` and `=======` are your local changes, while the lines between `=======` and `>>>>>>> branch_name` are incoming changes from another branch.
3. **Resolve Conflicts**:
   - Edit the file to keep the changes you want. You can choose to accept one side's changes or merge them manually.
   - Remove the conflict markers (`<<<<<<<<<`, `=======`, `>>>>>>>`) and any unnecessary spacing.
   - Save the file after resolving the conflict.
4. **Add Resolved Files**: After you've edited and saved the conflicted files, stage them for commit using:
   ```bash
   git add conflicted_file.txt
   ```
   You can use `git status` to check which files are still unmerged.
5. **Commit the Resolved Changes**:
   ```bash
   git commit -m "Resolved merge conflict"
   ```
6. **Push the Changes**:
   ```bash
   git push origin your_branch
   ```
   This will update the remote repository with your resolved changes.
   
7. **Cleanup** (optional): Once the conflict is resolved and the changes are pushed, you can delete the local branch you used for the conflict resolution if it's no longer needed:
   ```bash
   git branch -d branch_name
   ```
   If the branch contains changes that have not been merged elsewhere, use `-D` instead of `-d` to force deletion.
That's it! You've successfully resolved a merge conflict in Git. Remember that communication with your team is essential during conflict resolution, especially in collaborative projects, to ensure that the changes being merged are the intended ones.


Q.7) How to deploy code??
==> To deploy any git branch , we can use 2 different approach
->First Approach :- first i will checkout the branch , do the chnages , do testing
do maven (clean,compile ,install)
after that one JAR file will be generated , i will copy that jar and replace with JAR present on server

->Second Approach :- 
By using Jenkins , select the server , select branch , select service , confirm - that's it 

Q.8) Difference between Monolithic architecture & Microservices architecture
==>>
Monolithic architecture: Single, large application with tight coupling. Easier to develop initially but can become complex and hard to scale and maintain as it grows.

Microservices architecture: Collection of small, independent services. More complex to set up but allows for better scalability, maintainability, and flexibility in large and evolving applications.

Q.9) How many Bean Scopes in Spring??
==>In the Spring Framework, there are several bean scopes that define how Spring manages the lifecycle of a bean and controls when and how it is created and destroyed. The following are the common bean scopes in Spring:

1. **Singleton**: The default scope in Spring. Only one instance of the bean is created for the entire application context. This single instance is shared by all requesting components.

2. **Prototype**: A new instance of the bean is created every time it is requested. This allows for a fresh copy of the bean for each injection or lookup.

3. **Request**: A new instance is created for each HTTP request in a web application. This scope is only available in the context of a web application using Spring's web framework.

4. **Session**: A new instance is created for each HTTP session in a web application. Like the request scope, this is available in web applications.

5. **Global Session**: Similar to the session scope, but tied to a global session that spans across multiple web applications in a portlet environment. This scope is only relevant in portlet-based applications.

6. **Application**: A single instance is created for the entire lifetime of the application context. This is useful for creating beans that hold global application-level state.

7. **WebSocket**: Introduced in Spring 4.0, this scope is designed for web applications using WebSocket-based communication. A new instance is created for each WebSocket session.

8. **Custom Scopes**: Spring allows you to define custom bean scopes by implementing the `Scope` interface. This gives you the flexibility to create scopes tailored to your specific application needs.

The choice of bean scope depends on your specific requirements. For most beans, the default singleton scope is appropriate because it allows Spring to manage the bean's lifecycle and ensure it is shared when needed. However, there are scenarios where other scopes, like prototype or request, are more suitable. It's important to choose the scope that aligns with the intended behavior of your beans and the architecture of your application.


Q.10) what @Components Annotations & why using this??
==>
The `@Component` annotation in Spring is a fundamental part of the Spring Framework's component scanning mechanism and is used to declare a class as a Spring bean. When a class is annotated with `@Component`, Spring's container (ApplicationContext) automatically registers and manages the bean's lifecycle.
Here's how it works and why you would use it:
1. **Bean Definition**: By annotating a class with `@Component`, you're telling Spring that this class should be managed by the Spring container as a Spring bean. Spring then creates a bean definition for this class in the application context.
2. **Automatic Scanning**: To leverage the `@Component` annotation, you need to enable component scanning in your Spring configuration. Component scanning automatically searches for classes annotated with `@Component` (or its specializations like `@Service`, `@Repository`, and `@Controller`) within specified packages and registers them as beans.
3. **Dependency Injection**: Once a class is defined as a Spring bean, it can be injected into other beans, and you can use dependency injection to wire beans together. This promotes the Inversion of Control (IoC) principle, where control over the creation and management of objects is handed over to the Spring container.
4. **Simplifies Configuration**: Using `@Component` helps simplify your Spring configuration. You don't need to define the bean explicitly in XML or Java configuration. This makes your code more concise and reduces configuration overhead.
Here's an example of using `@Component`:
```java
@Component
public class MyService {
    // Class implementation
}
```
In this example, `MyService` is a Spring bean managed by the Spring container. You can then inject this bean into other components using constructor or setter injection.
```java
@Service
public class MyOtherService {
    private MyService myService;

    @Autowired
    public MyOtherService(MyService myService) {
        this.myService = myService;
    }
}
```
In this case, `@Service` is another specialization of `@Component`, commonly used for service classes.

Bottom line :- To use @Component and related annotations effectively, ensure that component scanning is enabled in your Spring configuration, and your component classes are located in packages that are scanned. This approach simplifies the configuration and helps manage your application's beans and their dependencies efficiently.


Q.11) Spring Boot Actuator??
==> To enable Spring Boot Actuator in your Spring Boot application, you need to add the spring-boot-starter-actuator dependency to your project's build configuration. You can then configure and customize the various actuator features in your application's properties or configuration files.
Spring Boot Actuator is a valuable addition to Spring Boot applications, especially in production environments, as it simplifies the process of monitoring and managing your application, making it easier to ensure its health and performance.
Spring Boot Actuator is a set of production-ready features provided by the Spring Boot framework to help monitor and manage your application. It offers a wide range of tools and capabilities to gather runtime information about your application, which can be useful for various purposes, including monitoring, debugging, and operational support.
Key features and capabilities of Spring Boot Actuator include:
1.Health Checks: /health endpoint reports application health, customizable for component checks like databases or message queues.
2.Application Information: /info endpoint provides metadata like version, build, or configuration data.
3.Metrics: /actuator/metrics exposes performance metrics, including custom ones.
4.Environment and Configuration: /actuator/env offers details on the application's environment and configuration.
5.Thread Dump: /actuator/threaddump provides thread-level insights for performance diagnostics.
6.Trace Information: /actuator/httptrace records and reveals details of HTTP interactions.
7.Auditing: Enables recording of events like method invocations in your app.
8.Custom Endpoints: Spring Boot Actuator allows you to create custom management endpoints. This is useful for exposing application-specific data or control features that can be accessed via HTTP.
9.Security: The actuator endpoints are sensitive by default, so Spring Boot Actuator provides security mechanisms to protect these endpoints. You can use Spring Security to configure access rules and authentication for these endpoints.
10.Integration with Monitoring Tools: Spring Boot Actuator is often used in conjunction with various monitoring and management tools, including Prometheus, Grafana, ELK (Elasticsearch, Logstash, Kibana), and others. These tools can collect, store, and visualize data from Actuator endpoints for comprehensive application monitoring.

Q.12)difference between synchronization and serialization in java ?
==>- **Synchronization**: Synchronization in Java is a mechanism to control access to shared resources by multiple threads, ensuring only one thread can access the resource at a time to prevent data inconsistencies and race conditions.

- **Serialization**: Serialization is the process of converting an object into a byte stream, making it suitable for storage or transmission, and deserialization is the reverse process of recreating the object from the byte stream. It's often used for saving objects to files or sending them over networks.

Q.13) Synchronus vs Ashynchronus in java??
===>>  										
  Synchronus: 
  In synchronous execution, operations are performed one after the other in a sequential manner. When a function or method is called, the   program waits for it to complete before moving on to the next operation. If the function takes a long time to execute or gets blocked for any reason, the entire program will be blocked, and no other tasks can be executed until the current task completes.

  Ashynchronus: 
	In asynchronous execution, tasks are initiated and allowed to run independently without waiting for them to complete. When a function or method is called, the program continues executing the next operation without blocking. The result of the asynchronous operation might not be immediately available, but the program can continue processing other tasks in the meantime.
	
Summary : 
Synchronous: Synchronous operations in Java are like standing in a queue; you wait for your turn, and the program blocks until the task is done.
Asynchronous: Asynchronous operations in Java are like sending tasks to workers; you don't wait in line, and the program continues with other tasks while waiting for results.

Q.14)ConcurrentModificationException ??
==>> This exception is thrown when an object is modified concurrently while an iteration is being performed on it using an iterator. It typically occurs in collections like ArrayList or HashMap when multiple threads attempt to modify the collection concurrently without proper synchronization.

Q.15)What is "fail-safe" and "fail-fast" in Java??
==>
Fail-Safe Iteration:
Fail-safe iteration allows multiple threads to modify a collection concurrently while other threads are iterating over it without throwing any exceptions.
Since the iteration is not performed on the original collection, any modifications made by other threads during the iteration won't be reflected in the iteration process.
The key benefit of the fail-safe approach is that it doesn't throw ConcurrentModificationException when the collection is modified during the iteration.
Fail-safe iterators are generally used in collections like ConcurrentHashMap and the CopyOnWriteArrayList, which are designed to handle concurrent modifications safely.

Fail-Fast Iteration: 
Fail-fast iteration, on the other hand, detects concurrent modifications during the iteration and immediately throws a ConcurrentModificationException to indicate that the collection has been structurally modified while being iterated.
Fail-fast iterators are used in most standard Java collections like ArrayList, HashSet, HashMap, etc. These collections are not designed to be thread-safe for concurrent modifications during iteration, and thus, they throw ConcurrentModificationException to signal potential issues.

Summary : 
Fail-safe iteration makes a copy of the collection and iterates over the copy, so it doesn't throw ConcurrentModificationException and allows modifications during the iteration.
Fail-fast iteration detects concurrent modifications during the iteration and immediately throws ConcurrentModificationException to ensure the collection's integrity.


Q.16) How to Delete Duplicate Rows in SQL?
==>>
DELETE FROM your_table_name
WHERE (column1, column2, ...) IN (
  SELECT column1, column2, ...
  FROM your_table_name
  GROUP BY column1, column2, ...
  HAVING COUNT(*) > 1
);
--->>

Q17. Nth Highest salary??
==>> 
select min(salary) from   
(select distinct salary from emp order by salary desc)   
where rownum < 3;  
  
In order to calculate the second highest salary use rownum < 3  
In order to calculate the third highest salary use rownum < 4  

OR 

SELECT *
FROM employee
ORDER BY salary DESC
LIMIT 1 OFFSET (N - 1);

In this query:
We select all columns (*) from the "employee" table.
We order the results in descending order of salary using ORDER BY salary DESC. This will list the employees with the highest salary at the top.
We use the LIMIT and OFFSET clauses to select the Nth highest salary. The LIMIT 1 clause ensures we only retrieve one row, and the OFFSET (N - 1) skips the first N - 1 rows, effectively giving you the Nth highest salary.

Q.18) Program java to find first & All non-repeating character of given String?
==>  method 1:  
class Main
{
    public static void main(String args[])
    {
        String inputStr ="prepinsta";
		boolean flag =true;
        
        for(char i :inputStr.toCharArray())
        {
            //if first occurs position same as last occurs position that means only one occurence of character
            if (inputStr.indexOf(i) == inputStr.lastIndexOf(i))
            {
                System.out.println("Non-repeating character is: "+ i);  
				
				//use below two statement only when you want just first non-repeating character 
				flag = false;
				break;
            }
        }        
	    //use below two statement only when you want just first non-repeating character 
        if(flag)
            System.out.println("There is no non repeating character in input string");			
    }
}
--->>
Method 2 : 
import java.util.*;
public class Main {
 public static void main(String[] args) {
  String str1 = "gibblegabbler";
  System.out.println("The given string is: " + str1);
  for (int i = 0; i < str1.length(); i++) {
   boolean unique = true;
   for (int j = 0; j < str1.length(); j++) {
    if (i != j && str1.charAt(i) == str1.charAt(j)) {
     unique = false;
     break;
    }
   }
   if (unique) {
    System.out.println("The first non repeated character in String is: " + str1.charAt(i));
    break;
   }
  }
 }
}


Q.19 )How the multiple thread stop execution??
In a multithreaded program, threads can be stopped in several ways. It's important to note that stopping a thread should be done carefully to avoid potential issues like resource leaks, data corruption, and thread synchronization problems. Here are some common methods for stopping threads:
1. **Thread Termination:**
   This is the simplest way to stop a thread. You can call the thread's `stop()` method, which will abruptly terminate the thread's execution. However, this method is highly discouraged because it can leave the program in an inconsistent state. The `stop()` method is deprecated in Java and other languages for this reason.
2. **Thread Interruption:**
   Threads can be interrupted using the `interrupt()` method. When you call `interrupt()` on a thread, it sets a flag indicating that the thread should be interrupted. However, it's up to the thread itself to respond to this interruption. You can use methods like `isInterrupted()` or `Thread.interrupted()` to check if a thread has been interrupted, and then you can decide how to gracefully stop the thread.
3. **Using Flags:**
   You can create a boolean flag that the thread periodically checks. When the flag is set to true, the thread can gracefully exit its execution loop and terminate. This allows for more controlled termination compared to abrupt thread termination.
   ```java
   volatile boolean shouldStop = false;

   public void run() {
       while (!shouldStop) {
           // Thread's work
       }
   }
   public void stopThread() {
       shouldStop = true;
   }
   ```
4. **Cooperative Thread Termination:**
   You can design your threads to be cooperative in their termination. Threads can communicate with each other and agree to stop based on certain conditions or events. This involves careful coordination between threads, using mechanisms like wait/notify in Java or condition variables in other languages.
5. **Using Thread Pools:**
   When working with thread pools, you can simply shut down the thread pool, which will stop all the threads it manages. This is a more high-level approach to managing thread termination in a pool of worker threads.
6. **Using higher-level abstractions:**
   In some programming languages or frameworks, you may have higher-level abstractions or libraries for managing concurrent tasks, which handle thread management for you. For instance, in Java, you can use the `ExecutorService` to manage thread execution and termination.
The choice of method depends on the specific requirements of your application and the language or framework you are using. It's important to handle thread termination gracefully to ensure that resources are released, data is not corrupted, and other threads are not affected adversely.

:::::::::::::::::::::::: Date : 17th-Oct-23 (Aaj sirf DBMS k question karta hu ):::::::::::::::::::::::::::::::::::::::::::

Q.20 )Parent of Exception class??
==> In Java, the `Exception` class is a subclass of the `Throwable` class, and `Throwable` is the parent class of both `Exception` and `Error`. Therefore, the inheritance hierarchy is as follows:
- `Throwable` (Parent of both `Exception` and `Error`)
  - `Exception`
  - `Error`
So, `Throwable` is the immediate parent of the `Exception` class in Java.

Q.21 )how many types of exceptions are there in Java??
==> two types , Checked and Unchecked

Q.22 )Try catch finally block in Java??
==> The try block encloses code that might throw exceptions.
The catch block(s) handle exceptions if they are thrown, with each catch block dedicated to a specific exception type.
The finally block contains code that always executes, whether an exception occurred or not. It is typically used for cleanup tasks.

Q.23 )What is ClassNotFoundException is there??
==>Class Not in Classpath: If the class you are trying to load is not present in the classpath, the JVM will throw a ClassNotFoundException. The classpath is a list of directories and JAR files where the JVM looks for classes.
Typographical Errors: If there are typographical errors or inconsistencies in the class name, including the package name, it can lead to a ClassNotFoundException.
Missing Dependency: If a class depends on another class that is not available at runtime, this can result in a ClassNotFoundException.
-
To resolve ClassNotFoundException, you should:
Ensure that the class you are trying to load is available in the classpath.
Verify that there are no typographical errors in the class name or package name.
Make sure all dependencies required by the class are available.
Properly managing the classpath and verifying the existence of classes and their dependencies will help prevent ClassNotFoundException errors in your Java applications.

Q.24) What are some examples of RuntimeExceptions in Java?

Answer: Some examples of RuntimeExceptions in Java include NullPointerException, ArithmeticException (e.g., division by zero), ArrayIndexOutOfBoundsException, and IllegalArgumentException.

Q.25) What is a Functional Interface in Java?

Answer: A Functional Interface in Java is an interface that contains only one abstract method. It can have multiple default or static methods, but it must have exactly one abstract method. The `@FunctionalInterface` annotation can be used to ensure that an interface is a functional interface.

Q.26) What is the Stream API in Java?

Answer: The Stream API in Java is a powerful set of classes introduced in Java 8 to perform functional-style operations on sequences of elements. It allows for concise and expressive code when working with collections, enabling operations like filtering, mapping, and reducing.

Q.27) What are the key differences between Java 8, Java 11, and Java 17?

Answer: Java 8 introduced significant features such as lambdas, the Stream API, and the java.time package for date and time. Java 11 and Java 17 are subsequent long-term support (LTS) releases that bring various improvements, performance enhancements, and new features. Some differences include module system enhancements, local-variable type inference (var), and the introduction of new features like records and pattern matching in later versions. It's essential to check the release notes for each version to understand specific changes and improvements.
====================================================================================================



#==> Birlasoft
-----------------------------------------------------------------------------------------------------------
Q.28) What are some key features introduced in Java 8?

Answer: Java 8 introduced several significant features, including:

- Lambdas: A concise way to express anonymous functions.
- Stream API: A set of classes to process sequences of elements using functional-style operations.
- Default Methods: Methods in interfaces with default implementations.
- Method References: A shorthand notation of a lambda expression to call a method.
- Functional Interfaces: Interfaces with a single abstract method, promoting functional programming.
- java.time Package: A modern date and time API.

Q.29) What are different methods used in the Stream API, such as filter, map, and collect?

Answer: In the Stream API, various methods facilitate functional-style operations on sequences of elements. Some commonly used methods include:

- `filter`: Selects elements based on a given predicate.
- `map`: Transforms each element using a provided function.
- `collect`: Gathers the elements into a collection.
- `forEach`: Performs an action on each element.
- `reduce`: Combines elements into a single result.

Q.30) What is the use of default and static methods in interfaces in Java 8?

Answer: In Java 8, interfaces can have default and static methods:

- Default Methods: These provide a default implementation in the interface, allowing classes that implement the interface to use the default method or override it.
- Static Methods: These are similar to static methods in classes, providing utility methods associated with the interface.

Q.31) What is the difference between Abstraction and Interface in the context of Java 8?

Answer: In Java 8, Abstraction refers to the process of hiding implementation details and showing only essential features. An interface, on the other hand, is a way to achieve abstraction in Java. Interfaces in Java 8 can have default and static methods, allowing for a degree of implementation in addition to abstraction.

Q.32) How does HashMap work internally in Java?

Answer: HashMap in Java uses a hash table to store key-value pairs. When an element is added to the HashMap, its key's hash code is used to compute a hash, which determines the index where the key-value pair will be stored. In case of hash collisions, the elements are stored in a linked list at that index. Java 8 introduced a tree structure for the linked lists to improve performance in certain scenarios.

Q.33) What extra features were added to HashMap in Java 8?

Answer: In Java 8, HashMap introduced the concept of a tree structure for linked lists when collisions occur. This optimizes performance for scenarios with a large number of hash collisions by transforming the linked list into a balanced tree, resulting in more efficient retrieval of elements.

Q.34) Can we write code without an ORM tool, only with Hibernate?

Answer: Hibernate is an ORM (Object-Relational Mapping) tool that simplifies database interaction in Java. While it is possible to write JDBC code or use other database access methods without an ORM tool, Hibernate provides a higher-level abstraction, making database operations more convenient and object-oriented.

Q.35) Explain the concept of Microservices Architecture.

Answer: Microservices Architecture is an architectural style where a software application is divided into small, independent services that can be developed, deployed, and scaled independently. Each microservice focuses on a specific business capability and communicates with other services through well-defined APIs. This approach enhances agility, scalability, and maintainability in large and complex applications.

Q.35) What is Spring Security?

Answer: Spring Security is a powerful and customizable authentication and access control framework for Java applications. It is part of the larger Spring Framework and provides comprehensive security services for Java EE-based enterprise software applications. Spring Security aims to simplify the implementation of security features like authentication, authorization, and protection against common security vulnerabilities.

Key features of Spring Security include:

1. **Authentication:** Provides mechanisms to authenticate users, supporting various authentication providers such as JDBC, LDAP, and custom implementations.

2. **Authorization:** Enables fine-grained access control through role-based or permission-based authorization, allowing developers to specify which users or roles can access specific resources.

3. **Web Security:** Offers security features for web applications, including support for securing URLs, handling login/logout processes, and protecting against common web vulnerabilities like cross-site scripting (XSS) and cross-site request forgery (CSRF).

4. **Integration with Spring Framework:** Seamlessly integrates with the broader Spring ecosystem, making it easy to combine security features with other Spring components.

5. **Customization:** Allows extensive customization through configuration or by implementing custom components to meet specific security requirements.

6. **Token-based Security:** Supports token-based security, useful for building RESTful APIs and stateless authentication mechanisms.

7. **Prevention of Common Security Threats:** Provides mechanisms to protect against common security threats such as session fixation, clickjacking, and session management.

Spring Security is widely used in enterprise-level applications to secure both traditional web applications and modern microservices. It plays a crucial role in ensuring the confidentiality, integrity, and availability of applications by addressing various security concerns.

Q.36 ) Programm in java to shifting elements in Array nth shifting
 ----->>>                       <<-----
import java.util.Arrays;

public class ArrayShift {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5, 6 };
        int shiftBy = 2;

        System.out.println("Original Array: " + Arrays.toString(arr));
        
        shiftArray(arr, shiftBy);

        System.out.println("Shifted Array: " + Arrays.toString(arr));
    }

    public static void shiftArray(int[] arr, int n) {
        int length = arr.length;
        int[] temp = new int[length];

        for (int i = 0; i < length; i++) {
            temp[(i + n) % length] = arr[i];
        }

        System.arraycopy(temp, 0, arr, 0, length);
    }
}
=============================================================================================================


#==> Tab Brillio
-----------------------------------------------------------------------------------------------------------
Java->
Q.37) What are the basic functions of the Stream API in Java?

Answer: The Stream API in Java provides a set of powerful functions for processing collections of data in a functional and declarative manner. The basic functions of the Stream API include:

- **Filtering:** The `filter` function allows you to selectively include or exclude elements from the stream based on a given predicate.

- **Mapping:** The `map` function transforms each element of the stream using a provided function, producing a new stream of transformed elements.

- **Reducing:** The `reduce` function combines the elements of the stream into a single result using an associative accumulation function.

- **Iterating:** The `forEach` function performs a specified action on each element of the stream, often used for side effects.

- **Collecting:** The `collect` function gathers the elements of the stream into a collection, such as a List, Set, or Map.

Q.38) Explain the methods `map`, `collect`, `Collector`, and `filter` in the Stream API.

Answer:

- **map():** The `map` method in the Stream API transforms each element of the stream using a provided function. It produces a new stream consisting of the transformed elements.

- **collect():** The `collect` method is used to accumulate the elements of a stream into a collection or other data structure. It takes a `Collector` as an argument to define the type of collection to be created.

- **Collector:** A `Collector` in the Stream API specifies how to transform the elements of a stream into a result. It defines the process of collecting elements into a container, applying additional transformations if needed.

- **filter():** The `filter` method is used to selectively include or exclude elements from a stream based on a specified predicate. It produces a new stream containing only the elements that satisfy the given condition.

Q.39) What is the purpose of the ClassLoader in Java?

Answer: The ClassLoader in Java is responsible for dynamically loading Java classes into the Java Virtual Machine (JVM) during runtime. It locates and loads the class files that are needed by a Java program. There are various types of ClassLoaders, including the Bootstrap ClassLoader, Extension ClassLoader, and Application ClassLoader, each responsible for loading classes from different sources.

Q.40) What is the difference between `put()` and `post()` methods in HTTP?

Answer: In HTTP (Hypertext Transfer Protocol), `put()` and `post()` are two different HTTP methods used to submit data to a server.

- **PUT:** The `put()` method is used to update or create a resource on the server. It submits data to be processed to a specified resource, and if the resource does not exist, it may create it.

- **POST:** The `post()` method is used to submit data to be processed to a specified resource. It is often used to create a new resource on the server.

Q.41) In Postman, what happens if you pass a null value, and how can you handle it?

Answer: If you pass a null value in Postman, the behavior depends on the API endpoint and how it is designed to handle null values. Some APIs may interpret null as an undefined or missing value, while others may consider it an invalid input.

To handle null values in Postman:

1. **Check API Documentation:** Refer to the API documentation to understand how the endpoint handles null values. Some APIs may require specific formats or handle null differently.

2. **Request Body:** If you are passing data in the request body, ensure that the JSON or form data is correctly formatted, and handle null values according to the API requirements.

3. **Query Parameters:** If null values are part of query parameters, check how the API interprets and handles them.

Always follow the guidelines provided by the API documentation and adjust your requests accordingly to avoid unexpected behavior.

Spring Boot->

Q.43) How do you map a one-to-many relationship in JPA?

Answer: To map a one-to-many relationship in JPA (Java Persistence API), you can use the `@OneToMany` annotation. Here's an example:

```java
@Entity
public class ParentEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<ChildEntity> children;

    // Getter and Setter methods
}

@Entity
public class ChildEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @ManyToOne
    @JoinColumn(name = "parent_id")
    private ParentEntity parent;

    // Getter and Setter methods
}
```

In this example, the `ParentEntity` has a one-to-many relationship with `ChildEntity`, and the `@OneToMany` annotation is used to define the mapping. The `mappedBy` attribute indicates the field in the `ChildEntity` that owns the relationship.

Q.44) What is the difference between a Controller and RestController in Spring?

Answer: In Spring, a `Controller` and `RestController` serve different purposes:

- **Controller:** A `Controller` in Spring is a class annotated with `@Controller`. It is typically used to create MVC (Model-View-Controller) applications, where it handles both HTTP requests and returns a view as a response. The methods in a `Controller` can return view names or model objects.

- **RestController:** A `RestController` in Spring is a specialization of `Controller` and is annotated with `@RestController`. It is designed specifically for building RESTful web services. The methods in a `RestController` return data directly (e.g., JSON or XML) rather than a view. Each method is annotated with `@RequestMapping` or other annotations for mapping HTTP requests.

Q.45) What is a Transaction in the context of a database, and how can you manage it in Spring?

Answer: A transaction in the context of a database represents a sequence of one or more SQL operations that are executed as a single unit of work. Transactions ensure data consistency and integrity by either committing all changes or rolling back if an error occurs.

In Spring, transaction management can be achieved using the `@Transactional` annotation. By annotating a method with `@Transactional`, you instruct Spring to manage a transaction for that method. If an exception occurs, the transaction is rolled back; otherwise, it is committed.

Example:

```java
@Service
public class MyService {
    @Autowired
    private MyRepository myRepository;

    @Transactional
    public void performTransactionalOperation() {
        // Database operations
        myRepository.save(entity1);
        myRepository.save(entity2);
    }
}
```

In this example, the `performTransactionalOperation` method is annotated with `@Transactional`, indicating that both `save` operations should be part of a single transaction.

Q.46) How can you read a file from application.properties in a Spring application?

Answer: To read a file path or other properties from the `application.properties` file in a Spring application, you can use the `@Value` annotation.

Example:

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MyService {
    @Value("${file.path}")
    private String filePath;

    // Other methods
}
```

In this example, the value of `file.path` from the `application.properties` file is injected into the `filePath` variable. Make sure to include the appropriate property key and value in the `application.properties` file.

Q.47) What methods are commonly used for saving and retrieving data in a Spring Data JPA Repository?

Answer: In a Spring Data JPA Repository, common methods for saving and retrieving data include:

- **Save Data:**
  - `save(entity)`: Saves a single entity.
  - `saveAll(entities)`: Saves multiple entities.

- **Retrieve Data:**
  - `findById(id)`: Retrieves an entity by its primary key.
  - `findAll()`: Retrieves all entities.
  - `findAllById(ids)`: Retrieves entities by their primary keys.
  - Custom query methods using naming conventions (e.g., `findByPropertyName`).

These methods are part of the basic CRUD (Create, Read, Update, Delete) operations provided by Spring Data JPA.

Q.48) Can you outline the structure of an end-to-end Spring Boot CRUD (Create, Read, Update, Delete) operation?

Answer: An end-to-end Spring Boot CRUD operation typically involves the following components:

1. **Entity Class:** Represents the data model and is annotated with `@Entity` and related annotations.

2. **Repository Interface:** Extends `JpaRepository` and defines custom query methods for data access.

3. **Service Class:** Implements business logic and interacts with the repository.

4. **Controller Class:** Handles HTTP requests, calls service methods, and returns responses.

5. **Application Properties:** Contains configuration properties, including database connection details.

6. **Database Setup:** Configures and connects to the database.

7. **RESTful Endpoints:** Define endpoints for creating, reading, updating, and deleting data.

8. **DTOs (Data Transfer Objects):** If needed, DTOs can be used to transfer data between layers.

Here's a simplified example structure:

```java
// Entity Class
@Entity
public class Item {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private double price;
    // other fields, getters, setters
}

// Repository Interface
public interface ItemRepository extends JpaRepository<Item, Long> {
    List<Item> findByName(String name);
}

// Service Class
@Service
public class ItemService {
    @Autowired
    private ItemRepository itemRepository;

    public List<Item> getAllItems() {
        return itemRepository.findAll();
    }

    // other service methods
}

// Controller Class
@RestController
@RequestMapping("/api/items")
public class ItemController {
    @Autowired
    private ItemService itemService;

    @GetMapping
    public List<Item> getAllItems() {
        return itemService.getAllItems();
    }

    // other controller methods
}
```

This structure follows the MVC pattern, where entities represent the data model, repositories handle database operations, services implement business logic, and controllers handle HTTP requests.

Q.49 )How to connect two database in spring boot ?
==>>> 
1. Define Configuration Properties:  In Application.properties and Yml file define properties for each database, including the       URL,username, password, and any other required configuration.
2. Create Configuration Classes:  Create separate configuration classes for each database. In each configuration class, use the @Configuration annotation and define a DataSource bean using the properties you've defined for that database.
3. Use the Databases in our Code:  In your services or repositories, you can specify which data source to use by qualifying the DataSource bean using the @Qualifier annotation.

Also 

Interviewer Follow-up Question: "Why might you need to connect to multiple databases in an application?"

Your Answer--->>>

Connecting to multiple databases can be useful in scenarios where you need to work with different types of data sources. For example:

Data Migration: You might need to migrate data from one database to another during a transition phase or system upgrade.

Microservices: Different microservices might use different databases based on their requirements, and you'd need to connect to each service's database.

Reporting and Analytics: You might have a transactional database for day-to-day operations and a separate database optimized for reporting and analytics.



Q.50 )How can we exclude one class from Auto Configuration ?

--->>> @SpringBootApplication(exclude = MyAutoConfiguration.class)

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::Q.43) How do you map a one-to-many relationship in JPA?

Answer: To map a one-to-many relationship in JPA (Java Persistence API), you can use the `@OneToMany` annotation. Here's an example:

```java
@Entity
public class ParentEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<ChildEntity> children;

    // Getter and Setter methods
}

@Entity
public class ChildEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @ManyToOne
    @JoinColumn(name = "parent_id")
    private ParentEntity parent;

    // Getter and Setter methods
}
```

In this example, the `ParentEntity` has a one-to-many relationship with `ChildEntity`, and the `@OneToMany` annotation is used to define the mapping. The `mappedBy` attribute indicates the field in the `ChildEntity` that owns the relationship.

Q.44) What is the difference between a Controller and RestController in Spring?

Answer: In Spring, a `Controller` and `RestController` serve different purposes:

- **Controller:** A `Controller` in Spring is a class annotated with `@Controller`. It is typically used to create MVC (Model-View-Controller) applications, where it handles both HTTP requests and returns a view as a response. The methods in a `Controller` can return view names or model objects.

- **RestController:** A `RestController` in Spring is a specialization of `Controller` and is annotated with `@RestController`. It is designed specifically for building RESTful web services. The methods in a `RestController` return data directly (e.g., JSON or XML) rather than a view. Each method is annotated with `@RequestMapping` or other annotations for mapping HTTP requests.

Q.45) What is a Transaction in the context of a database, and how can you manage it in Spring?

Answer: A transaction in the context of a database represents a sequence of one or more SQL operations that are executed as a single unit of work. Transactions ensure data consistency and integrity by either committing all changes or rolling back if an error occurs.

In Spring, transaction management can be achieved using the `@Transactional` annotation. By annotating a method with `@Transactional`, you instruct Spring to manage a transaction for that method. If an exception occurs, the transaction is rolled back; otherwise, it is committed.

Example:

```java
@Service
public class MyService {
    @Autowired
    private MyRepository myRepository;

    @Transactional
    public void performTransactionalOperation() {
        // Database operations
        myRepository.save(entity1);
        myRepository.save(entity2);
    }
}
```

In this example, the `performTransactionalOperation` method is annotated with `@Transactional`, indicating that both `save` operations should be part of a single transaction.

Q.46) How can you read a file from application.properties in a Spring application?

Answer: To read a file path or other properties from the `application.properties` file in a Spring application, you can use the `@Value` annotation.

Example:

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MyService {
    @Value("${file.path}")
    private String filePath;

    // Other methods
}
```

In this example, the value of `file.path` from the `application.properties` file is injected into the `filePath` variable. Make sure to include the appropriate property key and value in the `application.properties` file.

Q.47) What methods are commonly used for saving and retrieving data in a Spring Data JPA Repository?

Answer: In a Spring Data JPA Repository, common methods for saving and retrieving data include:

- **Save Data:**
  - `save(entity)`: Saves a single entity.
  - `saveAll(entities)`: Saves multiple entities.

- **Retrieve Data:**
  - `findById(id)`: Retrieves an entity by its primary key.
  - `findAll()`: Retrieves all entities.
  - `findAllById(ids)`: Retrieves entities by their primary keys.
  - Custom query methods using naming conventions (e.g., `findByPropertyName`).

These methods are part of the basic CRUD (Create, Read, Update, Delete) operations provided by Spring Data JPA.

Q.48) Can you outline the structure of an end-to-end Spring Boot CRUD (Create, Read, Update, Delete) operation?

Answer: An end-to-end Spring Boot CRUD operation typically involves the following components:

1. **Entity Class:** Represents the data model and is annotated with `@Entity` and related annotations.

2. **Repository Interface:** Extends `JpaRepository` and defines custom query methods for data access.

3. **Service Class:** Implements business logic and interacts with the repository.

4. **Controller Class:** Handles HTTP requests, calls service methods, and returns responses.

5. **Application Properties:** Contains configuration properties, including database connection details.

6. **Database Setup:** Configures and connects to the database.

7. **RESTful Endpoints:** Define endpoints for creating, reading, updating, and deleting data.

8. **DTOs (Data Transfer Objects):** If needed, DTOs can be used to transfer data between layers.

Here's a simplified example structure:

```java
// Entity Class
@Entity
public class Item {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private double price;
    // other fields, getters, setters
}

// Repository Interface
public interface ItemRepository extends JpaRepository<Item, Long> {
    List<Item> findByName(String name);
}

// Service Class
@Service
public class ItemService {
    @Autowired
    private ItemRepository itemRepository;

    public List<Item> getAllItems() {
        return itemRepository.findAll();
    }

    // other service methods
}

// Controller Class
@RestController
@RequestMapping("/api/items")
public class ItemController {
    @Autowired
    private ItemService itemService;

    @GetMapping
    public List<Item> getAllItems() {
        return itemService.getAllItems();
    }

    // other controller methods
}
```

This structure follows the MVC pattern, where entities represent the data model, repositories handle database operations, services implement business logic, and controllers handle HTTP requests.Q.43) How do you map a one-to-many relationship in JPA?

Answer: To map a one-to-many relationship in JPA (Java Persistence API), you can use the `@OneToMany` annotation. Here's an example:

```java
@Entity
public class ParentEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<ChildEntity> children;

    // Getter and Setter methods
}

@Entity
public class ChildEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @ManyToOne
    @JoinColumn(name = "parent_id")
    private ParentEntity parent;

    // Getter and Setter methods
}
```

In this example, the `ParentEntity` has a one-to-many relationship with `ChildEntity`, and the `@OneToMany` annotation is used to define the mapping. The `mappedBy` attribute indicates the field in the `ChildEntity` that owns the relationship.

Q.44) What is the difference between a Controller and RestController in Spring?

Answer: In Spring, a `Controller` and `RestController` serve different purposes:

- **Controller:** A `Controller` in Spring is a class annotated with `@Controller`. It is typically used to create MVC (Model-View-Controller) applications, where it handles both HTTP requests and returns a view as a response. The methods in a `Controller` can return view names or model objects.

- **RestController:** A `RestController` in Spring is a specialization of `Controller` and is annotated with `@RestController`. It is designed specifically for building RESTful web services. The methods in a `RestController` return data directly (e.g., JSON or XML) rather than a view. Each method is annotated with `@RequestMapping` or other annotations for mapping HTTP requests.

Q.45) What is a Transaction in the context of a database, and how can you manage it in Spring?

Answer: A transaction in the context of a database represents a sequence of one or more SQL operations that are executed as a single unit of work. Transactions ensure data consistency and integrity by either committing all changes or rolling back if an error occurs.

In Spring, transaction management can be achieved using the `@Transactional` annotation. By annotating a method with `@Transactional`, you instruct Spring to manage a transaction for that method. If an exception occurs, the transaction is rolled back; otherwise, it is committed.

Example:

```java
@Service
public class MyService {
    @Autowired
    private MyRepository myRepository;

    @Transactional
    public void performTransactionalOperation() {
        // Database operations
        myRepository.save(entity1);
        myRepository.save(entity2);
    }
}
```

In this example, the `performTransactionalOperation` method is annotated with `@Transactional`, indicating that both `save` operations should be part of a single transaction.

Q.46) How can you read a file from application.properties in a Spring application?

Answer: To read a file path or other properties from the `application.properties` file in a Spring application, you can use the `@Value` annotation.

Example:

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MyService {
    @Value("${file.path}")
    private String filePath;

    // Other methods
}
```

In this example, the value of `file.path` from the `application.properties` file is injected into the `filePath` variable. Make sure to include the appropriate property key and value in the `application.properties` file.

Q.47) What methods are commonly used for saving and retrieving data in a Spring Data JPA Repository?

Answer: In a Spring Data JPA Repository, common methods for saving and retrieving data include:

- **Save Data:**
  - `save(entity)`: Saves a single entity.
  - `saveAll(entities)`: Saves multiple entities.

- **Retrieve Data:**
  - `findById(id)`: Retrieves an entity by its primary key.
  - `findAll()`: Retrieves all entities.
  - `findAllById(ids)`: Retrieves entities by their primary keys.
  - Custom query methods using naming conventions (e.g., `findByPropertyName`).

These methods are part of the basic CRUD (Create, Read, Update, Delete) operations provided by Spring Data JPA.

Q.48) Can you outline the structure of an end-to-end Spring Boot CRUD (Create, Read, Update, Delete) operation?

Answer: An end-to-end Spring Boot CRUD operation typically involves the following components:

1. **Entity Class:** Represents the data model and is annotated with `@Entity` and related annotations.

2. **Repository Interface:** Extends `JpaRepository` and defines custom query methods for data access.

3. **Service Class:** Implements business logic and interacts with the repository.

4. **Controller Class:** Handles HTTP requests, calls service methods, and returns responses.

5. **Application Properties:** Contains configuration properties, including database connection details.

6. **Database Setup:** Configures and connects to the database.

7. **RESTful Endpoints:** Define endpoints for creating, reading, updating, and deleting data.

8. **DTOs (Data Transfer Objects):** If needed, DTOs can be used to transfer data between layers.

Here's a simplified example structure:

```java
// Entity Class
@Entity
public class Item {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private double price;
    // other fields, getters, setters
}

// Repository Interface
public interface ItemRepository extends JpaRepository<Item, Long> {
    List<Item> findByName(String name);
}

// Service Class
@Service
public class ItemService {
    @Autowired
    private ItemRepository itemRepository;

    public List<Item> getAllItems() {
        return itemRepository.findAll();
    }

    // other service methods
}

// Controller Class
@RestController
@RequestMapping("/api/items")
public class ItemController {
    @Autowired
    private ItemService itemService;

    @GetMapping
    public List<Item> getAllItems() {
        return itemService.getAllItems();
    }

    // other controller methods
}
```

This structure follows the MVC pattern, where entities represent the data model, repositories handle database operations, services implement business logic, and controllers handle HTTP requests.Q.43) How do you map a one-to-many relationship in JPA?

Answer: To map a one-to-many relationship in JPA (Java Persistence API), you can use the `@OneToMany` annotation. Here's an example:

```java
@Entity
public class ParentEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<ChildEntity> children;

    // Getter and Setter methods
}

@Entity
public class ChildEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @ManyToOne
    @JoinColumn(name = "parent_id")
    private ParentEntity parent;

    // Getter and Setter methods
}
```

In this example, the `ParentEntity` has a one-to-many relationship with `ChildEntity`, and the `@OneToMany` annotation is used to define the mapping. The `mappedBy` attribute indicates the field in the `ChildEntity` that owns the relationship.

Q.44) What is the difference between a Controller and RestController in Spring?

Answer: In Spring, a `Controller` and `RestController` serve different purposes:

- **Controller:** A `Controller` in Spring is a class annotated with `@Controller`. It is typically used to create MVC (Model-View-Controller) applications, where it handles both HTTP requests and returns a view as a response. The methods in a `Controller` can return view names or model objects.

- **RestController:** A `RestController` in Spring is a specialization of `Controller` and is annotated with `@RestController`. It is designed specifically for building RESTful web services. The methods in a `RestController` return data directly (e.g., JSON or XML) rather than a view. Each method is annotated with `@RequestMapping` or other annotations for mapping HTTP requests.

Q.45) What is a Transaction in the context of a database, and how can you manage it in Spring?

Answer: A transaction in the context of a database represents a sequence of one or more SQL operations that are executed as a single unit of work. Transactions ensure data consistency and integrity by either committing all changes or rolling back if an error occurs.

In Spring, transaction management can be achieved using the `@Transactional` annotation. By annotating a method with `@Transactional`, you instruct Spring to manage a transaction for that method. If an exception occurs, the transaction is rolled back; otherwise, it is committed.

Example:

```java
@Service
public class MyService {
    @Autowired
    private MyRepository myRepository;

    @Transactional
    public void performTransactionalOperation() {
        // Database operations
        myRepository.save(entity1);
        myRepository.save(entity2);
    }
}
```

In this example, the `performTransactionalOperation` method is annotated with `@Transactional`, indicating that both `save` operations should be part of a single transaction.

Q.46) How can you read a file from application.properties in a Spring application?

Answer: To read a file path or other properties from the `application.properties` file in a Spring application, you can use the `@Value` annotation.

Example:

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MyService {
    @Value("${file.path}")
    private String filePath;

    // Other methods
}
```

In this example, the value of `file.path` from the `application.properties` file is injected into the `filePath` variable. Make sure to include the appropriate property key and value in the `application.properties` file.

Q.47) What methods are commonly used for saving and retrieving data in a Spring Data JPA Repository?

Answer: In a Spring Data JPA Repository, common methods for saving and retrieving data include:

- **Save Data:**
  - `save(entity)`: Saves a single entity.
  - `saveAll(entities)`: Saves multiple entities.

- **Retrieve Data:**
  - `findById(id)`: Retrieves an entity by its primary key.
  - `findAll()`: Retrieves all entities.
  - `findAllById(ids)`: Retrieves entities by their primary keys.
  - Custom query methods using naming conventions (e.g., `findByPropertyName`).

These methods are part of the basic CRUD (Create, Read, Update, Delete) operations provided by Spring Data JPA.

Q.48) Can you outline the structure of an end-to-end Spring Boot CRUD (Create, Read, Update, Delete) operation?

Answer: An end-to-end Spring Boot CRUD operation typically involves the following components:

1. **Entity Class:** Represents the data model and is annotated with `@Entity` and related annotations.

2. **Repository Interface:** Extends `JpaRepository` and defines custom query methods for data access.

3. **Service Class:** Implements business logic and interacts with the repository.

4. **Controller Class:** Handles HTTP requests, calls service methods, and returns responses.

5. **Application Properties:** Contains configuration properties, including database connection details.

6. **Database Setup:** Configures and connects to the database.

7. **RESTful Endpoints:** Define endpoints for creating, reading, updating, and deleting data.

8. **DTOs (Data Transfer Objects):** If needed, DTOs can be used to transfer data between layers.

Here's a simplified example structure:

```java
// Entity Class
@Entity
public class Item {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private double price;
    // other fields, getters, setters
}

// Repository Interface
public interface ItemRepository extends JpaRepository<Item, Long> {
    List<Item> findByName(String name);
}

// Service Class
@Service
public class ItemService {
    @Autowired
    private ItemRepository itemRepository;

    public List<Item> getAllItems() {
        return itemRepository.findAll();
    }

    // other service methods
}

// Controller Class
@RestController
@RequestMapping("/api/items")
public class ItemController {
    @Autowired
    private ItemService itemService;

    @GetMapping
    public List<Item> getAllItems() {
        return itemService.getAllItems();
    }

    // other controller methods
}
```

This structure follows the MVC pattern, where entities represent the data model, repositories handle database operations, services implement business logic, and controllers handle HTTP requests.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::Q.43) How do you map a one-to-many relationship in JPA?

Answer: To map a one-to-many relationship in JPA (Java Persistence API), you can use the `@OneToMany` annotation. Here's an example:

```java
@Entity
public class ParentEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<ChildEntity> children;

    // Getter and Setter methods
}

@Entity
public class ChildEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @ManyToOne
    @JoinColumn(name = "parent_id")
    private ParentEntity parent;

    // Getter and Setter methods
}
```

In this example, the `ParentEntity` has a one-to-many relationship with `ChildEntity`, and the `@OneToMany` annotation is used to define the mapping. The `mappedBy` attribute indicates the field in the `ChildEntity` that owns the relationship.

Q.44) What is the difference between a Controller and RestController in Spring?

Answer: In Spring, a `Controller` and `RestController` serve different purposes:

- **Controller:** A `Controller` in Spring is a class annotated with `@Controller`. It is typically used to create MVC (Model-View-Controller) applications, where it handles both HTTP requests and returns a view as a response. The methods in a `Controller` can return view names or model objects.

- **RestController:** A `RestController` in Spring is a specialization of `Controller` and is annotated with `@RestController`. It is designed specifically for building RESTful web services. The methods in a `RestController` return data directly (e.g., JSON or XML) rather than a view. Each method is annotated with `@RequestMapping` or other annotations for mapping HTTP requests.

Q.45) What is a Transaction in the context of a database, and how can you manage it in Spring?

Answer: A transaction in the context of a database represents a sequence of one or more SQL operations that are executed as a single unit of work. Transactions ensure data consistency and integrity by either committing all changes or rolling back if an error occurs.

In Spring, transaction management can be achieved using the `@Transactional` annotation. By annotating a method with `@Transactional`, you instruct Spring to manage a transaction for that method. If an exception occurs, the transaction is rolled back; otherwise, it is committed.

Example:

```java
@Service
public class MyService {
    @Autowired
    private MyRepository myRepository;

    @Transactional
    public void performTransactionalOperation() {
        // Database operations
        myRepository.save(entity1);
        myRepository.save(entity2);
    }
}
```

In this example, the `performTransactionalOperation` method is annotated with `@Transactional`, indicating that both `save` operations should be part of a single transaction.

Q.46) How can you read a file from application.properties in a Spring application?

Answer: To read a file path or other properties from the `application.properties` file in a Spring application, you can use the `@Value` annotation.

Example:

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MyService {
    @Value("${file.path}")
    private String filePath;

    // Other methods
}
```

In this example, the value of `file.path` from the `application.properties` file is injected into the `filePath` variable. Make sure to include the appropriate property key and value in the `application.properties` file.

Q.47) What methods are commonly used for saving and retrieving data in a Spring Data JPA Repository?

Answer: In a Spring Data JPA Repository, common methods for saving and retrieving data include:

- **Save Data:**
  - `save(entity)`: Saves a single entity.
  - `saveAll(entities)`: Saves multiple entities.

- **Retrieve Data:**
  - `findById(id)`: Retrieves an entity by its primary key.
  - `findAll()`: Retrieves all entities.
  - `findAllById(ids)`: Retrieves entities by their primary keys.
  - Custom query methods using naming conventions (e.g., `findByPropertyName`).

These methods are part of the basic CRUD (Create, Read, Update, Delete) operations provided by Spring Data JPA.

Q.48) Can you outline the structure of an end-to-end Spring Boot CRUD (Create, Read, Update, Delete) operation?

Answer: An end-to-end Spring Boot CRUD operation typically involves the following components:

1. **Entity Class:** Represents the data model and is annotated with `@Entity` and related annotations.

2. **Repository Interface:** Extends `JpaRepository` and defines custom query methods for data access.

3. **Service Class:** Implements business logic and interacts with the repository.

4. **Controller Class:** Handles HTTP requests, calls service methods, and returns responses.

5. **Application Properties:** Contains configuration properties, including database connection details.

6. **Database Setup:** Configures and connects to the database.

7. **RESTful Endpoints:** Define endpoints for creating, reading, updating, and deleting data.

8. **DTOs (Data Transfer Objects):** If needed, DTOs can be used to transfer data between layers.

Here's a simplified example structure:

```java
// Entity Class
@Entity
public class Item {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private double price;
    // other fields, getters, setters
}

// Repository Interface
public interface ItemRepository extends JpaRepository<Item, Long> {
    List<Item> findByName(String name);
}

// Service Class
@Service
public class ItemService {
    @Autowired
    private ItemRepository itemRepository;

    public List<Item> getAllItems() {
        return itemRepository.findAll();
    }

    // other service methods
}

// Controller Class
@RestController
@RequestMapping("/api/items")
public class ItemController {
    @Autowired
    private ItemService itemService;

    @GetMapping
    public List<Item> getAllItems() {
        return itemService.getAllItems();
    }

    // other controller methods
}
```

This structure follows the MVC pattern, where entities represent the data model, repositories handle database operations, services implement business logic, and controllers handle HTTP requests.Q.43) How do you map a one-to-many relationship in JPA?

Answer: To map a one-to-many relationship in JPA (Java Persistence API), you can use the `@OneToMany` annotation. Here's an example:

```java
@Entity
public class ParentEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<ChildEntity> children;

    // Getter and Setter methods
}

@Entity
public class ChildEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @ManyToOne
    @JoinColumn(name = "parent_id")
    private ParentEntity parent;

    // Getter and Setter methods
}
```

In this example, the `ParentEntity` has a one-to-many relationship with `ChildEntity`, and the `@OneToMany` annotation is used to define the mapping. The `mappedBy` attribute indicates the field in the `ChildEntity` that owns the relationship.

Q.44) What is the difference between a Controller and RestController in Spring?

Answer: In Spring, a `Controller` and `RestController` serve different purposes:

- **Controller:** A `Controller` in Spring is a class annotated with `@Controller`. It is typically used to create MVC (Model-View-Controller) applications, where it handles both HTTP requests and returns a view as a response. The methods in a `Controller` can return view names or model objects.

- **RestController:** A `RestController` in Spring is a specialization of `Controller` and is annotated with `@RestController`. It is designed specifically for building RESTful web services. The methods in a `RestController` return data directly (e.g., JSON or XML) rather than a view. Each method is annotated with `@RequestMapping` or other annotations for mapping HTTP requests.

Q.45) What is a Transaction in the context of a database, and how can you manage it in Spring?

Answer: A transaction in the context of a database represents a sequence of one or more SQL operations that are executed as a single unit of work. Transactions ensure data consistency and integrity by either committing all changes or rolling back if an error occurs.

In Spring, transaction management can be achieved using the `@Transactional` annotation. By annotating a method with `@Transactional`, you instruct Spring to manage a transaction for that method. If an exception occurs, the transaction is rolled back; otherwise, it is committed.

Example:

```java
@Service
public class MyService {
    @Autowired
    private MyRepository myRepository;

    @Transactional
    public void performTransactionalOperation() {
        // Database operations
        myRepository.save(entity1);
        myRepository.save(entity2);
    }
}
```

In this example, the `performTransactionalOperation` method is annotated with `@Transactional`, indicating that both `save` operations should be part of a single transaction.

Q.46) How can you read a file from application.properties in a Spring application?

Answer: To read a file path or other properties from the `application.properties` file in a Spring application, you can use the `@Value` annotation.

Example:

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MyService {
    @Value("${file.path}")
    private String filePath;

    // Other methods
}
```

In this example, the value of `file.path` from the `application.properties` file is injected into the `filePath` variable. Make sure to include the appropriate property key and value in the `application.properties` file.

Q.47) What methods are commonly used for saving and retrieving data in a Spring Data JPA Repository?

Answer: In a Spring Data JPA Repository, common methods for saving and retrieving data include:

- **Save Data:**
  - `save(entity)`: Saves a single entity.
  - `saveAll(entities)`: Saves multiple entities.

- **Retrieve Data:**
  - `findById(id)`: Retrieves an entity by its primary key.
  - `findAll()`: Retrieves all entities.
  - `findAllById(ids)`: Retrieves entities by their primary keys.
  - Custom query methods using naming conventions (e.g., `findByPropertyName`).

These methods are part of the basic CRUD (Create, Read, Update, Delete) operations provided by Spring Data JPA.

Q.48) Can you outline the structure of an end-to-end Spring Boot CRUD (Create, Read, Update, Delete) operation?

Answer: An end-to-end Spring Boot CRUD operation typically involves the following components:

1. **Entity Class:** Represents the data model and is annotated with `@Entity` and related annotations.

2. **Repository Interface:** Extends `JpaRepository` and defines custom query methods for data access.

3. **Service Class:** Implements business logic and interacts with the repository.

4. **Controller Class:** Handles HTTP requests, calls service methods, and returns responses.

5. **Application Properties:** Contains configuration properties, including database connection details.

6. **Database Setup:** Configures and connects to the database.

7. **RESTful Endpoints:** Define endpoints for creating, reading, updating, and deleting data.

8. **DTOs (Data Transfer Objects):** If needed, DTOs can be used to transfer data between layers.

Here's a simplified example structure:

```java
// Entity Class
@Entity
public class Item {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private double price;
    // other fields, getters, setters
}

// Repository Interface
public interface ItemRepository extends JpaRepository<Item, Long> {
    List<Item> findByName(String name);
}

// Service Class
@Service
public class ItemService {
    @Autowired
    private ItemRepository itemRepository;

    public List<Item> getAllItems() {
        return itemRepository.findAll();
    }

    // other service methods
}

// Controller Class
@RestController
@RequestMapping("/api/items")
public class ItemController {
    @Autowired
    private ItemService itemService;

    @GetMapping
    public List<Item> getAllItems() {
        return itemService.getAllItems();
    }

    // other controller methods
}
```

This structure follows the MVC pattern, where entities represent the data model, repositories handle database operations, services implement business logic, and controllers handle HTTP requests.Q.43) How do you map a one-to-many relationship in JPA?

Answer: To map a one-to-many relationship in JPA (Java Persistence API), you can use the `@OneToMany` annotation. Here's an example:

```java
@Entity
public class ParentEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<ChildEntity> children;

    // Getter and Setter methods
}

@Entity
public class ChildEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields

    @ManyToOne
    @JoinColumn(name = "parent_id")
    private ParentEntity parent;

    // Getter and Setter methods
}
```

In this example, the `ParentEntity` has a one-to-many relationship with `ChildEntity`, and the `@OneToMany` annotation is used to define the mapping. The `mappedBy` attribute indicates the field in the `ChildEntity` that owns the relationship.

Q.44) What is the difference between a Controller and RestController in Spring?

Answer: In Spring, a `Controller` and `RestController` serve different purposes:

- **Controller:** A `Controller` in Spring is a class annotated with `@Controller`. It is typically used to create MVC (Model-View-Controller) applications, where it handles both HTTP requests and returns a view as a response. The methods in a `Controller` can return view names or model objects.

- **RestController:** A `RestController` in Spring is a specialization of `Controller` and is annotated with `@RestController`. It is designed specifically for building RESTful web services. The methods in a `RestController` return data directly (e.g., JSON or XML) rather than a view. Each method is annotated with `@RequestMapping` or other annotations for mapping HTTP requests.

Q.45) What is a Transaction in the context of a database, and how can you manage it in Spring?

Answer: A transaction in the context of a database represents a sequence of one or more SQL operations that are executed as a single unit of work. Transactions ensure data consistency and integrity by either committing all changes or rolling back if an error occurs.

In Spring, transaction management can be achieved using the `@Transactional` annotation. By annotating a method with `@Transactional`, you instruct Spring to manage a transaction for that method. If an exception occurs, the transaction is rolled back; otherwise, it is committed.

Example:

```java
@Service
public class MyService {
    @Autowired
    private MyRepository myRepository;

    @Transactional
    public void performTransactionalOperation() {
        // Database operations
        myRepository.save(entity1);
        myRepository.save(entity2);
    }
}
```

In this example, the `performTransactionalOperation` method is annotated with `@Transactional`, indicating that both `save` operations should be part of a single transaction.

Q.46) How can you read a file from application.properties in a Spring application?

Answer: To read a file path or other properties from the `application.properties` file in a Spring application, you can use the `@Value` annotation.

Example:

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MyService {
    @Value("${file.path}")
    private String filePath;

    // Other methods
}
```

In this example, the value of `file.path` from the `application.properties` file is injected into the `filePath` variable. Make sure to include the appropriate property key and value in the `application.properties` file.

Q.47) What methods are commonly used for saving and retrieving data in a Spring Data JPA Repository?

Answer: In a Spring Data JPA Repository, common methods for saving and retrieving data include:

- **Save Data:**
  - `save(entity)`: Saves a single entity.
  - `saveAll(entities)`: Saves multiple entities.

- **Retrieve Data:**
  - `findById(id)`: Retrieves an entity by its primary key.
  - `findAll()`: Retrieves all entities.
  - `findAllById(ids)`: Retrieves entities by their primary keys.
  - Custom query methods using naming conventions (e.g., `findByPropertyName`).

These methods are part of the basic CRUD (Create, Read, Update, Delete) operations provided by Spring Data JPA.

Q.48) Can you outline the structure of an end-to-end Spring Boot CRUD (Create, Read, Update, Delete) operation?

Answer: An end-to-end Spring Boot CRUD operation typically involves the following components:

1. **Entity Class:** Represents the data model and is annotated with `@Entity` and related annotations.

2. **Repository Interface:** Extends `JpaRepository` and defines custom query methods for data access.

3. **Service Class:** Implements business logic and interacts with the repository.

4. **Controller Class:** Handles HTTP requests, calls service methods, and returns responses.

5. **Application Properties:** Contains configuration properties, including database connection details.

6. **Database Setup:** Configures and connects to the database.

7. **RESTful Endpoints:** Define endpoints for creating, reading, updating, and deleting data.

8. **DTOs (Data Transfer Objects):** If needed, DTOs can be used to transfer data between layers.

Here's a simplified example structure:

```java
// Entity Class
@Entity
public class Item {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private double price;
    // other fields, getters, setters
}

// Repository Interface
public interface ItemRepository extends JpaRepository<Item, Long> {
    List<Item> findByName(String name);
}

// Service Class
@Service
public class ItemService {
    @Autowired
    private ItemRepository itemRepository;

    public List<Item> getAllItems() {
        return itemRepository.findAll();
    }

    // other service methods
}

// Controller Class
@RestController
@RequestMapping("/api/items")
public class ItemController {
    @Autowired
    private ItemService itemService;

    @GetMapping
    public List<Item> getAllItems() {
        return itemService.getAllItems();
    }

    // other controller methods
}
```

This structure follows the MVC pattern, where entities represent the data model, repositories handle database operations, services implement business logic, and controllers handle HTTP requests.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
>>>>>>>>>>>>> 50 Question Completed here on - 22nd Nov 2023 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

=============================================================================================================

#==> Tech Mahindra
-----------------------------------------------------------------------------------------------------------
Q.51 )Circuit Breaker in Microservices
Q.52 )All Spring boot Controller class and services class formate
Q.53 )exception Handling 
Q.54 )ConcurrentModificationException
Q.55 )Dependency Injuction
Q.56 )Java 8 features
Q.57 )OOps Concept
Q.58 )Internal Working of HashMap
Q.59 )Marker Interface
Q.60 )What is Serilization
Q.61 )Finally Block
Q.62 )Is there Any way where Finally will not Execute
Q.63 )Bean Scopes 
==========================================================================================================


#==> Again Birlasoft and Incido
-----------------------------------------------------------------------------------------------------------
Java->
Q.64 )Polimorphism
Q.65 )Compile Time and runtime Polimorphism
Q.66 )Abstraction and real work
Q.67 )Java 8 All features
Q.68 )Marker Interface
Q.69 )Serialization vs DeSerilization
Q.70 )optional class
Q.71 )Stream Api
Q.72 )Arraylist vs LinkedList
Q.73 )HashMap working or it is Synchronized or not
Q.74 )ConcurrentHashMap
Q.75 )Custom Exception 

Spring Boot->
Q.76 )@Requestmapping
Q.77 )DI
Q.78 )How to Connect with Databases
Q.79 )How to error Handling in Spring Boot
Q.80 )How to test private class in Junit
Q.81 )About JPA
Q.82 )save vs saveAll

Microservices->
Q.83 )Microservices vs Monolethic Architecture
Q.84 )How the services Communicate with Each other
Q.85 )In one srvices fails than what
Q.86 )What dependency will requirs for Register the Services in Ureka Server
Q.87 )what is Circuit Breaker

==========================================================================================================


#==> Saturday Interview Capgemini , Cognizant , Incedo , Infosys
-----------------------------------------------------------------------------------------------------------
Spring Boot 
Q.88 )IOC 
Q.89 )DI
Q.90 )How to Call External API or SOAP API in Spring Boot
Q.91 )How to Configure Multiple Database in Spring Boot
Q.92 )Spring Boot Profiles
Q.93 )In our project what are the Security features are there 
Q.94 )Postman error codes like 400 , 200 , 500 and when they come
Q.95 )How to change default Server in Spring boot
Q.96 )flow of data from JPA to Database
Q.97 )all end to end Architecture in Spring Boot
Q.98 )About Repository CRUD operations
Q.99 )if we hit Https and response will come in later than how we can manage\
Q.100 )How to pass Hater from Postman
Q.101 )Patch()

Microservices
Q.102 ) diff b/w Monolethic and Microservices architecture
Q.103 ) Circuit breaker
Q.104 ) if one services fails than how manage
Q.105 ) Basic End to End Flow

Java
Q.106 ) HashMap vs HashTable
Q.107 ) NullPointerException i.e Optional Class
Q.108 ) Java 8 basic Program
Q.109 ) Internal working of HashMap
Q.110 ) List vs Set
Q.111 ) OPPs Concept
Q.112 ) See Basic on Multithreading
Q.113 ) See all Basic Programming

==========================================================================================================

#==> BirlaSoft Second Round
-----------------------------------------------------------------------------------------------------------
Java-> 
Q.114 ) Version
Q.115 ) Diff Java7 vs Java8
Q.116 ) Methods in Stream Api

Spring Boot->
Q.117 ) Spring Boot version
Q.118 ) why need of version
Q.119 ) default server
Q.120 ) How to change version
Q.121 ) Flow of Spring Boot
Q.122 ) How to Add Plugins in Spring Boot
Q.123 ) Diff between XML vs Annotations based Spring   

Rest API->
Q.124 ) What Server use
Q.125 ) How to connect with backend

==========================================================================================================


#==> Capgemini L2 Round
-----------------------------------------------------------------------------------------------------------
Q.126 ) Architecture of your project
Q.127 ) Which Design Patter used in Project

Q.128 ) Sql query synchronus vs Asyn Queries
==> 
Synchronous Queries:
1.Blocking Execution:
   - Synchronous queries block the application's execution until the query is completed.
   SELECT * FROM Customers;
2.Predictable Flow:
   - Code execution follows a linear, step-by-step model, making it easier to understand and debug.
   INSERT INTO Orders (CustomerID, ProductID) VALUES (123, 456);
3.Wait for Completion:
   - The application waits for the query to finish before continuing with other tasks.
   
Asynchronous Queries:
1.Non-Blocking Execution:
   - Asynchronous queries allow the application to continue executing other tasks while waiting for the query to complete.
   -- Using JavaScript with Node.js and a promise-based library like pg-promise
   db.query('SELECT * FROM Customers')
       .then(result => {
           // Handle the result
       })
       .catch(error => {
           // Handle errors
       });
2. Concurrency and Responsivenes:
   - Asynchronous queries are beneficial for applications requiring concurrency and responsiveness, as they don't block the application's main thread.
   -- Using Python with the `asyncio` library and an async database driver
   async with create_pool() as pool:
       async with pool.acquire() as connection:
           result = await connection.execute('SELECT * FROM Customers')
           # Handle the result asynchronously
3. **Complex Handling:**
   - Handling asynchronous queries can be more complex, often involving callbacks, promises, or event-driven programming.

Q.129 ) How to pass validation from PostMan
Q.130 ) About Frequently Company Change

==========================================================================================================


#==> Cognizant wed 23rd August
-----------------------------------------------------------------------------------------------------------
   
Q.131 ) Architecture of your project
Q.132 ) Functional Interface  and Some preDefined Functional Interfaces
Q.133 ) Why new Java version Required
Q.134 ) In which Project Spring and Spring Boot used
Q.135 ) Features of Spring Boot
Q.136 ) Methods in Repository
Q.137 ) @Transactional Annotation use
Q.138 ) Day to Day Activity
Q.139 ) Test Cases and SonarLint
Q.140 ) Agile Methedology
Q.141 ) In which Domain u have worked till now?
Q.142 ) Have you worked on Some Leadership Positions?

==========================================================================================================

#==> LTIMindtree
-----------------------------------------------------------------------------------------------------------
Q.143 ) what is transient in java ??
Q.144 ) Can we override Main methods in java?? -->> We can Overload main method but not Override main method 
Q.145 ) Actuators in Spring Boot??

Q.146 ) View in Sql??
==> In SQL, a view is a virtual table that is based on the result of a SELECT query. A view allows you to simplify complex queries, provide a layer of abstraction over the underlying tables, and restrict access to specific columns or rows of data. Views do not store data themselves; they are stored queries that are executed when you query the view.
Certainly, here are the benefits of using views in SQL in short points:
1.Simplicity:Views simplify complex queries by encapsulating query logic.
2.Security: Views can restrict access to specific columns or rows, enhancing data security.
3.Abstraction: Views provide a layer of abstraction over underlying tables, shielding users from table changes.
4.Performance: Views can improve performance by pre-computing and storing query results.
5.Consistency: Views maintain a consistent interface to data, even if the physical data storage evolves.
6.Code Reusability: Views can be used in multiple queries, promoting code reusability.

Q.147 ) hashMap itreration with Iterator Method?
Q.148 ) WAP to print repeated city name from list of City String?
Q.149 ) How two services are communicationg with each other??

==========================================================================================================


#==> Publicis Sapient
-----------------------------------------------------------------------------------------------------------
Q.150 ) explain about the Projects in current company and previous company details
Q.151 ) OOps concepts 
Q.152 ) Abstraction with Real example
Q.153 ) Stream Api Methods
Q.154) Sort elements using Stream Api 
Q.155 ) Exception handling
Q.156 ) Syncronious vs non Synchronus 
Q.157 ) Hashmap working
Q.158 ) HashMap vs hashTable related to thread safe 
Q.159 ) List vs set
Q.160 ) Array vs List
Q.161 ) Concurrancy exceptions
Q.162 ) Production Support 
Q.163 ) How to priority Bug 

Q.164 ) Joins
==>

Q.165 ) Second Highest Salary Sql query
==>

==========================================================================================================


#==> SILDIA
-----------------------------------------------------------------------------------------------------------
Q.166 ) explain about the project you have done in your previous company in detail
Q.167 ) Spring security and how we can implement it in our project
Q.168 ) what does @Cross-origin do
Q.169 ) Difference in stringbuider and stringbuffer
Q.170 ) How can you configure the properties of your application
Q.171 ) what is keycloak and how does it work and why should we use it in our project
Q.172 ) How to connect your application with database
Q.173 ) What is stream api with filter and map ? give a proper example with explaination
Q.174 ) Why should we use elasticsearch(ELK)?    



   




